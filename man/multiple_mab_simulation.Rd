% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/multiple_mab_simulation.R
\name{multiple_mab_simulation}
\alias{multiple_mab_simulation}
\title{Run Multiple Multi-Arm-Bandit Trials with Inference in Parallel}
\usage{
multiple_mab_simulation(
  data,
  assignment_method,
  algorithm,
  conditions,
  prior_periods,
  perfect_assignment,
  whole_experiment,
  blocking,
  data_cols,
  times,
  seeds,
  control_augment = 0,
  time_unit = NULL,
  period_length = NULL,
  block_cols = NULL,
  verbose = FALSE,
  keep_data = FALSE,
  ndraws = 5000,
  random_assign_prop = 0
)
}
\arguments{
\item{data}{A data.frame, data.table, or tibble containing input data from the trial. This should be the results
of a traditional Randomized Controlled Trial (RCT). data.frames will be converted to tibbles internally.}

\item{assignment_method}{A character string; one of "Date", "Batch", or "Individual", to define the assignment into treatment waves. When using
"Batch" or "Individual", ensure your dataset is pre-arranged in the proper order observations should be considered so that
groups are assigned correctly. For "Date", observations will be considered in chronological order.
"Individual" assignment can be time-consuming for larger datasets.}

\item{algorithm}{A character string specifying the MAB algorithm to use. Options are "Thompson" or "UCB1".}

\item{conditions}{A named character vector containing treatment conditions. The elements
of this vector should be the names of each treatment as seen in your data, so to create it you can simply call
\code{unique(df[[condition_col_name]])}. The names of each element are used to reference the contents but are not inherently important;
choose names that are meaningful and consistent. If \code{control_augment} > 0, then the control condition
of the trial in this vector must have the name "Control".}

\item{prior_periods}{A numeric value of length 1, or the character string "All"; number of previous periods to use
in the treatment assignment model. This is used to implement the stationary/non-stationary bandit.
For example, a non-stationary bandit assumes the true probability of success for each treatment changes over time, so to
account for that, not all prior data should be used when making decisions because it could be "out of date".}

\item{perfect_assignment}{A logical value; if TRUE, assumes perfect information for treatment assignment
(i.e., all outcomes are observed regardless of the date).
If FALSE, hides outcomes not yet theoretically observed, based
on the dates treatments would have been assigned for each wave.
This is useful when simulating batch-based assignment where treatments were assigned
on a given day whether or not all the information from a prior batch was available and
you have exact dates treatments were assigned.}

\item{whole_experiment}{A logical value; if TRUE, uses all past experimental data for imputing outcomes.
If FALSE, uses only data available up to the current period. In large datasets or with a high number
of periods, setting this to FALSE can be more computationally intensive, though not a significant
contributor to total runtime.}

\item{blocking}{A logical value; whether or not to use treatment blocking. Treatment blocking is used to ensure an even-enough
distribution of treatment conditions across blocks. For example, blocking by gender would mean the randomized assignment should
split treatments evenly not just throughout the sample (so for 4 arms, 25-25-25-25), but also within each block, so 25\% of men
would receive each treatment and 25\% of women the same.}

\item{data_cols}{A named character vector containing the names of columns in \code{data} as strings:
\itemize{
\item \code{id_col}: Column in \code{data}; contains unique ID as a key.
\item \code{success_col}: Column in \code{data}; binary successes from the original experiment.
\item \code{condition_col}: Column in \code{data}; original treatment condition for each observation.
\item \code{date_col}: Column in \code{data}; contains original date of event/trial. Only necessary when assigning by "Date". Must be of type \code{Date}, not a character string.
\item \code{month_col}: Column in \code{data}; contains month of treatment. Only necessary when \code{time_unit = "Month"}. This can be a string or factor variable
containing the names or numbers of months.
\item \code{success_date_col}: Column in \code{data}; contains original dates each success occurred. Only necessary when \code{perfect_assignment = FALSE}. Must be of type \code{Date}, not a character string.
\item \code{assignment_date_col}: Column in \code{data}; contains original dates treatments were assigned to observations. Only necessary when \code{perfect_assignment = FALSE}.
Used to simulate imperfect information on the part of researchers conducting an adaptive trial. Must be of type \code{Date}, not a character string.
}}

\item{times}{A numeric value of length 1, the number of simulations to conduct.}

\item{seeds}{An integer vector of \code{length(times)} containing valid seeds to define random state for each trial.}

\item{control_augment}{A numeric value ranging from 0 to 1; proportion of each wave guaranteed to receive the "Control" treatment.
Default is 0.}

\item{time_unit}{A character string specifying the unit of time for assigning periods when \code{assignment_method} is "Date".
Acceptable values are "Day", "Week", or "Month". "Month" is a special case that is useful when an experiment
defines the months differently then the genuine dates, i.e. an experiment considers August as starting
the in the second half of July, or when exact calender months are required for the periods, not just
a lengths of time in the month range. As such it requires an additional column to be provided,
with the exact month desired for each observation, and it treats each observation
as occurring on the first of that month. It is also useful when dates are not provided, here
synthetic dates should be created placing each observation on the first on its specified month.}

\item{period_length}{A numeric value of length 1; represents the length of each treatment period.
If assignment method is "Date", this refers to the
length of periods by your specified \code{time_unit} (i.e., if "Day", 10 would be 10 days).
If assignment method is "Batch", this refers to the number of people in each batch. This factor
contributes most to the computational cost of calling the function, as large batch sizes make each iteration of
the simulation run slower, while each additional period adds time because of the extra iterations.
If you have a large dataset, consider passing it as a data.table.}

\item{block_cols}{A character vector of variables to block by. This vector should not be named.}

\item{verbose}{Logical; Toggles progress bar from \code{\link[furrr:future_map]{furrr::future_map()}} and other intermediate messages.}

\item{keep_data}{Logical; Whether or not to keep the final data from each trial. Recommended FALSE for large datasets.
.}

\item{ndraws}{A logical value; If TRUE, numerical corrections are made to the input
vector of success and total trials to when the Thompson Sampling procedure returns a vector
of 0's or NaN's due to overflow. The vectors are divided by 2, maintaining the proportions of
success to total trials in each arm, but this may impact the variance of the distribution. This occurs
recursively a maximum of 50 times before throwing an error. By default this is FALSE.}
}
\value{
\code{multiple.mab} class object, which is a named list containing:
\itemize{
\item \verb{final_data_nest:} tibble or data.table containing the nested tibbles/data.tables from each trial. Only provided when \code{keep_data} is TRUE.
\item \code{bandits}: A tibble or data.table containing the UCB1 statistics or Thompson Sampling posterior distributions for each period of each trial.
\item \code{assignment_probs}: A tibble or data.table containing the probability of being assigned each treatment arm at a given period of each trial.
\item \code{estimates}: A tibble or data.table containing the
AIPW (Augmented Inverse Probability Weighting) treatment effect estimates and variances, and traditional
sample means and variances, for each treatment arm, in each trial.
\item \code{settings}: A named list of the configuration settings used in the trial.
\item \code{original_data}: The original \code{data} object passed to the function (data.frame, tibble, or data.table).
}
}
\description{
Performs multiple Multi-Arm Bandit Trials using the same
simulation and inference backend as \code{\link[=single_mab_simulation]{single_mab_simulation()}}. Allows for
easy execution of multiple trials under the same settings to gauge the variance
of the procedure across execution states. Additionally supports parallel processing
through the \href{https://cran.r-project.org/web/packages/future/index.html}{future} and
\href{https://cran.r-project.org/web/packages/furrr/index.html}{furrr} packages.
}
\details{
This function simulates multiple adaptive Multi-Arm-Bandit Trials, using experimental
data from a traditional randomized experiment. It follows the same core procedure as
\code{\link[=single_mab_simulation]{single_mab_simulation()}} (see @details, there for a description), but conducts
more than one simulation. This allows researchers to gauge the variance
of the simulation procedure itself, and use that to form an empirical sampling distribution
of the AIPW estimates, instead of relying around asymptotic normality (Hadad et al. 2021) for inference.

The settings specified here have the same meaning as in \code{\link[=single_mab_simulation]{single_mab_simulation()}}, outside of the additional
parameters like \code{times} and \code{seeds} which define the number of multiple trials and random seeds to ensure reproducibility.
An important note is that \code{seeds} can only take integer values, so they bust be declared or coerced as valid integers,
passing doubles (even ones that are mathematical integers) will result in an error. It is recommended to use \code{sample.int()},
with a known seed beforehand to generate the values. Additionally, it is highly recommended to
set \code{keep_data} to FALSE as the memory used by the function will exponentially increase. This can cause
significant performance issues, especially if your system must swap to disk because memory is full.

The function provides support for parallel processing via the \href{https://cran.r-project.org/web/packages/future/index.html}{future} and
\href{https://cran.r-project.org/web/packages/furrr/index.html}{furrr} packages. When conducting a large
number of simulations, parallelization can improve performance if sufficient system resources are available.
Parallel processing must be explicitly set by the user, through \code{future::plan()}.
Windows users should set the plan to "multisession", while Linux and MacOS users can use "multicore" or "multisession".
Users running in a High Performance Computing environment (HPC), are encouraged to use
\href{https://cran.r-project.org/web/packages/future.batchtools/index.html}{future.batchtools},
for their respective HPC scheduler.
Note that parallel processing is not guaranteed to work on all systems, and may require additional setup or debugging effort
from the user. For any issues, users are encouraged to consult the documentation of the above packages.
}
\examples{
# Multiple_mab_simulation() is a useful tool for running multiple trials
# using the same configuration settings, in different random states
data(tanf)
# Subsetting to make the example faster
tanf <- tanf[1:50, ]

# The seeds passed must be integers, so it is highly recommended to create them
# before using `sample.int()`
set.seed(1)
seeds <- sample.int(10000, 5)
conditions <- c("no_letter", "open_appt", "specific_appt")

# For this example, period_length is set a large interval and
# times is low to keep run time short.
start <- proc.time()
x <- multiple_mab_simulation(
  data = tanf,
  assignment_method = "Batch",
  period_length = 25,
  whole_experiment = TRUE,
  blocking = FALSE,
  perfect_assignment = TRUE,
  algorithm = "Thompson",
  prior_periods = "All",
  control_augment = 0,
  conditions = conditions,
  data_cols = c(
    condition_col = "condition",
    id_col = "id",
    success_col = "success"
  ),
  verbose = FALSE, times = 5, seeds = seeds, keep_data = TRUE
)
seq_time <- proc.time() - start
print(x)

# Its Recommenced to set keep_data at FALSE unless necessary to avoid
# the output from taking up to much memory
# Keep TRUE
object.size(x)
x$final_data_nest <- NULL
# Size if Keep was FALSE
object.size(x)

# multiple_mab_simulation() is implemented using furrr::future_map()
# so you can also run simulations in parallel using futures.
# Simply run your preferred plan and number of cores before multiple_mab_simulation.
# Like: 
\dontrun{

  future::plan("plan", workers = n)
  multiple_mab_simulation(data = tanf,
                          assignment_method = "Batch",
                          period_length = 25,
                          whole_experiment = TRUE,
                          blocking = FALSE,
                          perfect_assignment = TRUE,
                          algorithm = "Thompson",
                          prior_periods = "All",
                          control_augment = 0,
                          conditions = conditions,
                          data_cols = c(
                            condition_col = "condition",
                            id_col = "id",
                            success_col = "success"
                          ),
                          verbose = FALSE, times = 5, seeds = seeds, keep_data = TRUE
  )
  future::plan("sequential")
}
# If your on Windows plan needs to be multisession
# If your on Unix (MacOS/Linux) you can use multicore or multisession
# If your running the code on a high performance cluster, look into
# using the future.batchtools API for whichever scheduler is used

# Check the future and furrr documentation for more details on possible options
}
\references{
Bengtsson, Henrik. 2025. “Future: Unified Parallel and Distributed Processing in R for Everyone.”
\url{https://cran.r-project.org/web/packages/future/index.html}.

Bengtsson, Henrik. 2025. “Future.Batchtools: A Future API for Parallel and Distributed Processing Using ‘Batchtools.’”
\url{https://cran.r-project.org/web/packages/future.batchtools/index.html}.

Hadad, Vitor, David A. Hirshberg, Ruohan Zhan, Stefan Wager, and Susan Athey. 2021.
“Confidence Intervals for Policy Evaluation in Adaptive Experiments.”
Proceedings of the National Academy of Sciences of the United States of America 118 (15):
e2014602118. \url{https://doi.org/10.1073/pnas.2014602118}.

Kuleshov, Volodymyr, and Doina Precup. 2014. “Algorithms for Multi-Armed Bandit Problems.”
arXiv. https://doi.org/10.48550/arXiv.1402.6028.

Loecher, Thomas Lotze and Markus. 2022. “Bandit: Functions for Simple a/B Split Test and Multi-Armed Bandit Analysis.”
\url{https://cran.r-project.org/web/packages/bandit/index.html}.

Offer‐Westort, Molly, Alexander Coppock, and Donald P. Green. 2021.
“Adaptive Experimental Design: Prospects and Applications in Political Science.”
American Journal of Political Science 65 (4): 826–44. \url{https://doi.org/10.1111/ajps.12597}.

Slivkins, Aleksandrs. 2024. “Introduction to Multi-Armed Bandits.”
arXiv. \url{https://doi.org/10.48550/arXiv.1904.07272}.

Vaughan, Davis, Matt Dancho, and RStudio. 2022.
“Furrr: Apply Mapping Functions in Parallel Using Futures.”
\url{https://cran.r-project.org/web/packages/furrr/index.html}.
}
\seealso{
\code{\link[=single_mab_simulation]{single_mab_simulation()}}, \href{https://furrr.futureverse.org}{furrr}, \href{https://future.futureverse.org}{future}
}
